{
    "language": "Solidity",
    "sources": {
        "src/BidProtocol.sol": {
            "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"src/ReservoirOracle.sol\";\n\ncontract BidProtocol is Ownable, ReservoirOracle, ReentrancyGuard {\n    error WithdrawFailed(uint256 _amount);\n    error BidOracleFailed();\n    error SwapOutFailed(uint256 _amount);\n\n    event NftLiquidated();\n    event SwapIn(address indexed user, uint256 amountIn, uint256 percentIn);\n    event SwapOut(address indexed user, uint256 percentOut, uint256 amountOwed);\n    event Withdrawn(\n        address indexed user,\n        uint256 percentOut,\n        uint256 amountOwed\n    );\n\n    AggregatorV3Interface internal priceFeed;\n\n    uint256 private constant MAX_POOL_PERCENT = 100 * 1e18;\n    uint256 private constant MAX_PERCENT_OWNERSHIP = 1 * 1e18;\n    uint256 public MAX_MESSAGE_AGE = 5 minutes;\n\n    address private immutable _BID_ORACLE;\n    address public immutable NFT_CONTRACT;\n    uint256 public immutable TOKEN_ID;\n    uint256 public immutable SWAP_FEE;\n    uint256 public immutable INITIAL_NFT_PRICE;\n\n    uint256 public poolSize;\n    uint256 public percentInPool = 100 * 1e18;\n    uint256 public liquidatedPool;\n    uint256 public feePool;\n\n    mapping(address => uint256) public addressToPercent;\n\n    enum State {\n        Inactive,\n        Active,\n        PendingLiquidation,\n        Liquidated\n    }\n\n    enum PriceKind {\n        SPOT,\n        TWAP,\n        LOWER,\n        UPPER\n    }\n\n    State public state;\n\n    constructor(\n        address _NFT_CONTRACT,\n        uint256 _TOKEN_ID,\n        address BID_ORACLE,\n        address _PRICE_ORACLE,\n        uint256 _SWAP_FEE,\n        uint256 _INITIAL_NFT_PRICE\n    ) ReservoirOracle(BID_ORACLE) {\n        require(_NFT_CONTRACT != address(0), \"Invalid NFT contract\");\n        require(BID_ORACLE != address(0), \"Invalid nft oracle address\");\n        require(_PRICE_ORACLE != address(0), \"Invalid price oracle address\");\n        require(_INITIAL_NFT_PRICE != 0, \"Initial NFT price can't be 0\");\n        require(\n            _SWAP_FEE >= 0 && _SWAP_FEE <= 1e4,\n            \"Invalid swap fee percentage\"\n        );\n\n        NFT_CONTRACT = _NFT_CONTRACT;\n        TOKEN_ID = _TOKEN_ID;\n        INITIAL_NFT_PRICE = _INITIAL_NFT_PRICE;\n        //Remember: Swap fee should be in bps format (10**2)\n        SWAP_FEE = _SWAP_FEE * 1e16;\n\n        _BID_ORACLE = BID_ORACLE;\n        priceFeed = AggregatorV3Interface(_PRICE_ORACLE);\n    }\n\n    modifier isActive() {\n        require(state == State.Active, \"Pool is not active for swapping\");\n        _;\n    }\n\n    modifier isLiquidated() {\n        require(state == State.Liquidated, \"Pool is not active for withdraw\");\n        _;\n    }\n\n    /**\n     * LP/Owner functions\n     */\n\n    function updateReservoirOracleAddress(\n        address newAddress\n    ) public override onlyOwner {\n        require(newAddress != address(0), \"Invalid reservoir oracle address\");\n        RESERVOIR_ORACLE_ADDRESS = newAddress;\n    }\n\n    function updateMaxMessageAge(uint256 maxAge) public onlyOwner {\n        require(maxAge > 60, \"Minimum is 1 minute\");\n        MAX_MESSAGE_AGE = maxAge;\n    }\n\n    function updatePriceFeed(address newAddress) public onlyOwner {\n        require(newAddress != address(0), \"Invalid price oracle address\");\n        priceFeed = AggregatorV3Interface(newAddress);\n    }\n\n    function init() public payable onlyOwner {\n        require(state == State.Inactive, \"Pool is already active\");\n        require(msg.value != 0, \"Initial capital can't be 0\");\n\n        uint256 percentOfNFTValue = getPercentOf(msg.value, INITIAL_NFT_PRICE);\n        require(\n            percentOfNFTValue >= 5 * 1e18,\n            \"Initial capital needs to be 5% or above of initial NFT value\"\n        );\n\n        poolSize = msg.value;\n        state = State.Active;\n    }\n\n    function lpDeployMore() public payable onlyOwner isActive {\n        require(msg.value != 0, \"Capital can't be 0\");\n        poolSize += msg.value;\n    }\n\n    function lpPoolWithdraw(uint256 amount) public onlyOwner nonReentrant {\n        require(amount <= poolSize, \"Can't withdraw more than pool\");\n        poolSize -= amount;\n        (bool lpSent, ) = msg.sender.call{value: amount}(\"\");\n        if (!lpSent) revert WithdrawFailed(amount);\n    }\n\n    function lpLiquidatedWithdraw() public isLiquidated onlyOwner nonReentrant {\n        require(percentInPool != 0, \"No percent left in pool\");\n        uint256 amountOwed = getValueOwed(percentInPool, liquidatedPool);\n\n        percentInPool = 0;\n        (bool lpSent, ) = msg.sender.call{value: amountOwed}(\"\");\n        if (!lpSent) revert WithdrawFailed(amountOwed);\n    }\n\n    function lpFeeWithdraw() public onlyOwner nonReentrant {\n        uint256 feePoolCopy = feePool;\n        feePool = 0;\n        (bool lpSent, ) = msg.sender.call{value: feePoolCopy}(\"\");\n        if (!lpSent) revert WithdrawFailed(feePoolCopy);\n    }\n\n    //When NFT is liquidated this function will be called with the amount of ETH it was sold to bid pool for (reason: blur don't allow smart contracts to accept bids)\n    //Aware that this is a centralization issue and will be fixed before public release of protocol\n    function nftLiquidate() public payable onlyOwner {\n        require(\n            state == State.PendingLiquidation,\n            \"Pool is not expecting liquidation\"\n        );\n        require(msg.value != 0, \"Liquidated amount less than 0\");\n        liquidatedPool = msg.value;\n        state = State.Liquidated;\n    }\n\n    /**\n     * User functions\n     */\n\n    function swapIn(Message calldata message) public payable isActive {\n        require(percentInPool != 0, \"No percent left in pool\");\n        require(msg.value != 0, \"Value needs to be above 0\");\n\n        uint256 currentUserPercent = addressToPercent[msg.sender];\n        require(\n            currentUserPercent <= MAX_PERCENT_OWNERSHIP,\n            \"You already own max percent\"\n        );\n\n        //Calculate swap in value\n        uint256 feeValue = getValueOwed(SWAP_FEE, msg.value);\n        uint256 swapInValue = msg.value - feeValue;\n\n        //Get bid price in wei from Reservoir oracle\n        uint256 bidPrice = _getBid(message);\n\n        //Calculate percent without decimals\n        uint256 newPercent = getPercentOf(swapInValue, bidPrice);\n        require(newPercent != 0, \"Value is below minimum swap in value\");\n        uint256 totalPercent = currentUserPercent + newPercent;\n\n        require(\n            totalPercent <= MAX_PERCENT_OWNERSHIP,\n            \"This swap will exceed max percent\"\n        );\n        require(\n            totalPercent <= percentInPool,\n            \"This swap will exceed percent left\"\n        );\n\n        //All checks out, update pool and percent\n        poolSize += swapInValue;\n        percentInPool -= newPercent;\n        addressToPercent[msg.sender] = totalPercent;\n\n        //Save fee\n        if (feeValue > 0) feePool += feeValue;\n\n        emit SwapIn(msg.sender, msg.value, newPercent);\n    }\n\n    //Note: For now we'll only allow swapping out 100% of stake\n    function swapOut(Message calldata message) public isActive nonReentrant {\n        uint256 currentUserPercent = addressToPercent[msg.sender];\n        require(currentUserPercent != 0, \"You don't own any percent\");\n\n        uint256 bidPrice = _getBid(message);\n        uint256 amountOwed = getValueOwed(currentUserPercent, bidPrice);\n\n        uint256 feeValue = getValueOwed(SWAP_FEE, amountOwed);\n        uint256 userValue = amountOwed - feeValue;\n\n        if (amountOwed > poolSize) {\n            state = State.PendingLiquidation;\n            emit NftLiquidated();\n        } else {\n            poolSize -= amountOwed;\n            percentInPool += currentUserPercent;\n            addressToPercent[msg.sender] = 0;\n\n            //Save fee\n            if (feeValue > 0) feePool += feeValue;\n\n            (bool userSent, ) = msg.sender.call{value: userValue}(\"\");\n            if (!userSent) revert SwapOutFailed(userValue);\n\n            emit SwapOut(msg.sender, currentUserPercent, amountOwed);\n        }\n    }\n\n    function userWithdraw() public isLiquidated nonReentrant {\n        uint256 currentUserPercent = addressToPercent[msg.sender];\n        require(currentUserPercent != 0, \"You don't own any percent\");\n\n        uint256 amountOwed = getValueOwed(currentUserPercent, liquidatedPool);\n\n        addressToPercent[msg.sender] = 0;\n        (bool userSent, ) = msg.sender.call{value: amountOwed}(\"\");\n        if (!userSent) revert WithdrawFailed(amountOwed);\n\n        emit Withdrawn(msg.sender, currentUserPercent, amountOwed);\n    }\n\n    /**\n     * Percentage calculations\n     */\n\n    function getPercentOf(uint256 x, uint256 y) public pure returns (uint256) {\n        return (x * 100e18) / y;\n    }\n\n    function getValueOwed(uint256 x, uint256 y) public pure returns (uint256) {\n        return (((y * 1e18) * x) / (100 * 1e18)) / 1e18;\n    }\n\n    /**\n     * Easy getters\n     */\n\n    function getState() public view returns (State) {\n        return state;\n    }\n\n    function getEthMaticPrice() public view returns (int256) {\n        //Get eth price of 1 MATIC\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        //Convert to 1 ETH = x MATIC (e.g. 1800 Matic = 1 ETH). With four decimals.\n        return 1e22 / price;\n    }\n\n    /**\n     * Returns bid price from signed message\n     */\n\n    function _getBid(Message calldata message) public view returns (uint256) {\n        // Construct the message id on-chain (using EIP-712 structured-data hashing)\n        bytes32 id = keccak256(\n            abi.encode(\n                keccak256(\n                    \"ContractWideCollectionTopBidPrice(uint8 kind,uint256 twapSeconds,address contract)\"\n                ),\n                PriceKind.SPOT,\n                86_400,\n                NFT_CONTRACT\n            )\n        );\n        // Validate the message\n        uint256 maxMessageAge = MAX_MESSAGE_AGE;\n        if (!_verifyMessage(id, maxMessageAge, message)) {\n            revert BidOracleFailed();\n        }\n        (, uint256 price) = abi.decode(message.payload, (address, uint256));\n\n        uint256 conversion = uint256(getEthMaticPrice());\n        if (conversion == 0) revert BidOracleFailed();\n\n        uint256 convertedPrice = (price * conversion) / 1e4;\n        if (convertedPrice == 0) revert BidOracleFailed();\n\n        return convertedPrice;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
        },
        "lib/chainlink-brownie-contracts/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals()\n    external\n    view\n    returns (\n      uint8\n    );\n\n  function description()\n    external\n    view\n    returns (\n      string memory\n    );\n\n  function version()\n    external\n    view\n    returns (\n      uint256\n    );\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
        },
        "src/ReservoirOracle.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\n// Inspired by https://github.com/ZeframLou/trustus\nabstract contract ReservoirOracle {\n    // --- Structs ---\n\n    struct Message {\n        bytes32 id;\n        bytes payload;\n        // The UNIX timestamp when the message was signed by the oracle\n        uint256 timestamp;\n        // ECDSA signature or EIP-2098 compact signature\n        bytes signature;\n    }\n\n    // --- Errors ---\n\n    error InvalidMessage();\n\n    // --- Fields ---\n\n    address public RESERVOIR_ORACLE_ADDRESS;\n\n    // --- Constructor ---\n\n    constructor(address reservoirOracleAddress) {\n        require(reservoirOracleAddress != address(0), \"Invalid oracle address\");\n        RESERVOIR_ORACLE_ADDRESS = reservoirOracleAddress;\n    }\n\n    // --- Public methods ---\n\n    function updateReservoirOracleAddress(\n        address newReservoirOracleAddress\n    ) public virtual;\n\n    // --- Internal methods ---\n\n    function _verifyMessage(\n        bytes32 id,\n        uint256 validFor,\n        Message memory message\n    ) internal view virtual returns (bool success) {\n        // Ensure the message matches the requested id\n        if (id != message.id) {\n            return false;\n        }\n\n        // Ensure the message timestamp is valid\n        if (\n            message.timestamp > block.timestamp ||\n            message.timestamp + validFor < block.timestamp\n        ) {\n            return false;\n        }\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // Extract the individual signature fields from the signature\n        bytes memory signature = message.signature;\n        if (signature.length == 64) {\n            // EIP-2098 compact signature\n            bytes32 vs;\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n                s := and(\n                    vs,\n                    0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n                )\n                v := add(shr(255, vs), 27)\n            }\n        } else if (signature.length == 65) {\n            // ECDSA signature\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n        } else {\n            return false;\n        }\n\n        address signerAddress = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    // EIP-712 structured-data hash\n                    keccak256(\n                        abi.encode(\n                            keccak256(\n                                \"Message(bytes32 id,bytes payload,uint256 timestamp)\"\n                            ),\n                            message.id,\n                            keccak256(message.payload),\n                            message.timestamp\n                        )\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        // Ensure the signer matches the designated oracle address\n        return signerAddress == RESERVOIR_ORACLE_ADDRESS;\n    }\n}\n"
        },
        "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "@chainlink/=lib/chainlink-brownie-contracts/",
            "@openzeppelin/=lib/openzeppelin-contracts/",
            "chainlink-brownie-contracts/=lib/chainlink-brownie-contracts/",
            "ds-test/=lib/forge-std/lib/ds-test/src/",
            "forge-std/=lib/forge-std/src/",
            "openzeppelin-contracts/=lib/openzeppelin-contracts/"
        ],
        "optimizer": { "enabled": true, "runs": 100 },
        "metadata": { "bytecodeHash": "ipfs" },
        "outputSelection": {
            "*": {
                "": ["ast"],
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "london",
        "libraries": {}
    }
}
